# 索引

1. 索引的底层数据结构  
    大多数关系型数据库（如 MySQL）的索引是基于特定的数据结构构建的，这些数据结构允许快速查找和排序数据。  

    - B-Tree 索引  
    B-Tree（B 树） 是最常见的索引结构，具体实现通常为 B+Tree。在 B+Tree 中，所有实际的数据都存储在叶子节点，非叶子节点只存储键和指向子节点的指针。  
    查找过程：在 B+Tree 中查找数据时，首先从根节点开始，比较要查找的键值与当前节点中的键值，决定往哪个子节点方向继续查找，直到找到相应的叶子节点。如果找到了匹配的键值，就可以直接获取对应的数据或数据的地址。  
    优势：B+Tree 索引由于其平衡性，所有叶子节点在同一层级，查找的时间复杂度为 O(log n)，这使得它在处理大规模数据时非常高效。
    - Hash 索引  
    Hash 索引 使用哈希表的原理，通过将键值输入哈希函数生成哈希码，然后在哈希表中直接定位数据的位置。  
    查找过程：查询时，键值会通过相同的哈希函数计算得到哈希码，然后直接访问哈希表中对应的槽，返回数据。  
    优势：Hash 索引查询速度非常快，理论上可以达到 O(1) 的复杂度。  
    局限性：Hash 索引不支持范围查询，也不保持键值的顺序。因此，Hash 索引通常只适用于等值查询（=）。  
2. 索引的存储方式
    - 聚集索引（Clustered Index）  
    在聚集索引中，表中的数据行按照索引的顺序存储，索引本身就是数据，因此访问聚集索引就是直接访问数据。一般主键默认为聚集索引。  
    特点：  
        - 数据行的物理存储顺序和索引顺序一致，因此每个表只能有一个聚集索引。  
        - 聚集索引对范围查询（例如 BETWEEN, >=, <）非常高效，因为数据已经按照索引顺序排列，数据库可以快速定位并读取所需的行。  
        - 由于聚集索引中的数据直接存储在叶子节点，因此不需要额外的指针或引用，空间利用率较高。  
        - 插入、更新操作可能会引发数据行的重新排序或移动，导致开销较大，尤其是在插入的数据顺序与聚集索引的顺序不一致时。  
    - 非聚集索引（Non-Clustered Index）  
    在非聚集索引中，索引存储的是数据行的键值和指向数据行的指针。数据行的物理存储顺序和索引顺序是分开的。使用 `CREATE INDEX idx_name ON table_name(column_name);` 语句创建非聚集索引。  
    特点：  
        - 一个表可以有多个非聚集索引。
        - 查询时先通过索引找到对应的数据指针，然后通过指针访问数据。
        - 对于单列查找、等值查询，非聚集索引同样能提供很好的性能。但对于范围查询，由于数据行不按索引顺序存储，可能需要额外的跳转或扫描操作。  
        - 非聚集索引需要存储指针，因此会消耗更多的存储空间，尤其是当一个表有多个非聚集索引时。
        - 非聚集索引在数据插入、删除或更新时不需要对表中的数据行进行重新排序，只需要维护索引本身。因此，更新操作的开销相对较低。
3. 索引的查询加速机制  
    当执行一个 SQL 查询时，数据库首先会根据查询条件判断是否有合适的索引可用。如果有合适的索引，查询过程如下：
    - 从根节点开始查找：  
    查询过程从根节点开始，根据要查找的键值进行比较，决定向哪个子节点移动。例如，查找键值 50 时，如果根节点有两个子节点，其中一个子节点的范围是 0-49，另一个子节点的范围是 50-100，那么查询会选择第二个子节点继续查找。
    - 在内部节点中查找：  
    查找过程在内部节点中继续，类似于在根节点中的查找，通过键值比较逐级向下遍历。这个过程继续进行，直到到达叶子节点。
    - 在叶子节点中查找：  
    在叶子节点中找到匹配的键值。对于聚集索引，叶子节点直接存储了数据行；对于非聚集索引，叶子节点存储了指向数据行的指针或地址。
    如果是聚集索引，查询结果直接返回数据；如果是非聚集索引，则会根据指针找到数据行所在的页面，再从中读取数据。

    于是使用索引有以下优势：  
    - 减少扫描范围：索引通过有序存储数据，可以大幅减少查询时需要扫描的数据量快速定位满足条件的记录，而不需要进行全表扫描。
    - 提高排序效率：***使用索引列*** 进行排序（ORDER BY）时，由于索引已经有序，因此如果索引顺序与查询顺序一致，数据库可以直接按索引顺序返回结果，避免额外的排序操作。  
    - 索引覆盖：如果查询的所有字段都在索引中，数据库可以直接从索引返回结果，而不必访问数据行，这称为“索引覆盖查询”。
    - 预读：在遍历索引时，数据库会将可能需要访问的页面预先读入内存，减少磁盘 I/O 操作。
    - 范围查询：如果查询条件是 WHERE age BETWEEN 10 AND 20，数据库会在找到起始键值后，沿着叶子节点的链表顺序遍历，直到满足条件的最后一个键值。
    - 组合索引：对于多个列上的组合索引，数据库会依次使用每个列的值来查找，遵循“最左前缀匹配”原则，即优先使用组合索引中的第一列来进行查找。
4. 索引的维护
    - 插入/更新/删除：当对表进行插入、更新、删除操作时，数据库需要维护索引的数据结构。这包括在索引中插入新键、更新现有键或者删除键。这些操作会带来一定的额外开销。
    - 索引失效：某些情况下，索引可能无法被充分利用，比如对索引列进行函数操作或者数据类型不匹配等情况。这些都会导致数据库不得不进行全表扫描逐行检查，而不是使用索引。
5. 索引的优化策略
    - 选择性：选择性越高的列（即列中不同值越多），索引的效果越好。一般情况下，应对选择性高的列创建索引。
    - 复合索引：对于多个列的查询条件，可以创建复合索引（多个列组合在一起的索引），但要注意列的顺序应该和查询中的顺序匹配。
    - 避免过多索引：虽然索引可以提高查询速度，但过多的索引会增加写操作的成本，因此应根据查询频率和重要性选择性创建索引。

## 使用EXPLAIN 关键字检查索引是否生效

### EXPLAIN 执行计划的输出字段

EXPLAIN 语句的结果通常包含以下字段：

- id
  - 代表查询中操作的序列号，包含数字的步骤将被依次执行。对于联合查询，id 不同的部分会按照 id 的值从大到小执行。
- select_type
  - 指出每个 SELECT 语句的类型，常见的有：
    - SIMPLE：简单查询，不包含子查询或联合查询。
    - PRIMARY：如果一个查询中包含子查询或联合查询，最外层的查询会标记为 PRIMARY。
    - SUBQUERY：子查询中的 SELECT。
    - DERIVED：派生表查询。派生表查询与子查询的区别主要在于，子查询生成的结果集通常是一个标量值、一行或多行数据，直接用于主查询的条件判断或计算，不会在最终结果中体现，例如:  `SELECT * FROM students WHERE age > (SELECT AVG(age) FROM students);
`
    其中的子查询 `(SELECT AVG(age) FROM students)` 返回一个标量值，该值用于主查询的 WHERE 子句中进行条件过滤。  
    但派生表在 FROM 子句中的子查询生成的结果集被视为一个临时表，并且可以像普通表一样在查询中使用，形如 `SELECT d.xxx FROM (SELECT ...) AS d`， 派生表 d 中的数据会直接体现在结果中。假设有以下查询：

    ```sql
    EXPLAIN SELECT d.student_id, d.avg_score
    FROM (SELECT student_id, AVG(score) AS avg_score FROM scores GROUP BY student_id) AS d
    WHERE d.avg_score > 75;
    ```

    这个查询首先生成一个派生表 d，它包含了每个学生的平均分数，然后对这些结果进行过滤。执行计划可能如下：

    id|select_type|table|type|possible_keys|key|key_len|ref|rows|Extra
    ---|---|---|---|---|---|---|---|---|---
    1|PRIMARY|`<derived2>`|ALL|NULL|NULL|NULL|NULL|5|Using where
    2|DERIVED|scores|ALL|NULL|NULL|NULL|NULL|20|Using temporary; Using filesort
    - UNION：联合查询的第二个或后续的 SELECT。
    - UNION RESULT：从 UNION 得到的结果集。
- table
  - 表示正在访问的表的名称。如果是子查询或派生表，则会显示 `<derivedX>`，其中 X 是派生表的序列号。
- partitions
  - 显示查询访问的分区（如果表分区了），否则为空。
- type
  - 表示 MySQL 在执行查询时如何访问表中的数据。不同的访问类型代表了不同的效率和处理方式。
    - system：表示要访问的表中只有一行数据。
    - const：表示要访问的表中最多只有一行匹配条件，通常用于主键或唯一索引的查询。
    - eq_ref：表示对要访问的表中的每行数据，都要从另一张表中读取一行数据。通常用于连接操作，其中一个表的列是另一个表的主键或唯一键。例如：`EXPLAIN SELECT * FROM orders JOIN customers ON orders.customer_id = customers.customer_id;`，customer_id 是 customers 表的主键、唯一索引，因此对要访问的 orders 表中的每一行，都会从 customers 表中读取且只能读取到一行数据。
    - ref：表示非唯一索引扫描，返回匹配某个单个值的所有行。例如：`EXPLAIN SELECT * FROM orders WHERE customer_id = 1234;`，在 orders 表中，customer_id 不是唯一索引，MySQL 会使用 ref 类型，查找所有与 customer_id = 1234 匹配的行。
    - range：表示检索特定范围内的行，使用索引。通常用于 BETWEEN、>, <, IN 等操作。
    - index：表示全索引扫描，MySQL 读取整个索引来满足查询需求。比 ALL 类型快，因为索引文件通常比数据文件小。
    - ALL：表示全表扫描，MySQL 需要读取整个表来查找匹配的行。
- possible_keys
  - 显示查询时可能会用到的索引，但不一定实际使用。
- key
  - 实际使用的索引。如果 key 为空，表示没有使用索引。
- key_len
  - 表示索引的长度（字节数），反映 MySQL 使用索引的字节数。长度越小，性能通常越好。
- ref
  - 显示查询的哪一列或常量与 key 索引一起被使用。
- rows
  - 估算了 MySQL 认为需要读取的行数。值越大，查询可能越慢。
- filtered
  - 反映了查询条件的选择性，即在所有扫描的行中，有多少比例的行满足查询条件。值的范围是 0 到 100，表示从没有行通过过滤条件（0%）到所有行都通过过滤条件（100%）。filtered 是 MySQL 优化器估算的值，不是实际的运行时结果。
- Extra
  - 包含额外信息，通常用来解释查询是否有优化空间。常见的值有：
    - Using index：查询中只使用索引字段，不需要访问表的记录。
    - Using where：索引被使用，但还需要在过滤后的数据上应用 WHERE 条件。
    - Using filesort：MySQL 需要对数据进行排序，这通常表示没有使用索引排序，可能会导致性能问题。
    - Using temporary：MySQL 需要使用临时表来存储结果集，这通常意味着有子查询或排序操作，可能导致性能下降。
