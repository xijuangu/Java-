# Java 多线程

## 线程

充分利用程序的等待时间，让CPU在多个程序中进行切换，充分利用CPU，从而提高程序的运行效率。

并发（Concurrency）
定义：并发是指多个任务在同一时间段内交替执行，但在某一时刻只能有一个任务在执行。
特点：并发主要是通过时间片轮转的方式实现，看起来像同时执行。

并行（Parallelism）
定义：并行是指多个任务在同一时刻同时执行。
特点：并行需要多核处理器，多个任务真正地同时运行。

### 线程的生命周期

- 新建状态:
使用 `new` 关键字和 `Thread` 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 `start()` 这个线程。
- 就绪状态:
当线程对象调用了`start()`方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
- 运行状态:
如果就绪状态的线程获取 CPU 资源，就可以执行 `run()`，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
- 阻塞状态:
如果一个线程执行了睡眠`sleep`、挂起`suspend`等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：
  - 等待阻塞：运行状态中的线程执行 `wait()` 方法，使线程进入到等待阻塞状态。
  - 同步阻塞：线程在获取 `synchronized` 同步锁失败(因为同步锁被其他线程占用)。
  - 其他阻塞：通过调用线程的 `sleep()` 或 `join()` 发出了 I/O 请求时，线程就会进入到阻塞状态。当`sleep()` 状态超时，`join()` 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
- 死亡状态:
一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

### 线程的优先级

每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。

Java 线程的优先级是一个整数，其取值范围是 `1 (Thread.MIN_PRIORITY ) - 10 (Thread.MAX_PRIORITY)`。

默认情况下，每一个线程都会分配一个优先级 `NORM_PRIORITY(5)`。

具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。

## 多线程的实现方式

### 继承Thread

1. 定义一个继承Thread的类，其中是要执行的任务
2. 重写run()方法
3. 创建子类的对象，并start()启动线程

```java
package org.xijuangu;

class MyThread extends Thread {     // 定义一个继承Thread的类，其中是要执行的任务
    @Override
    public void run(){              // 重写run()方法
        for(int i = 0; i < 100; i++){
            System.out.println(super.getName() + " is running");    // 此处不用super应该也行，只是表明这是父类Thread的方法，这里相当于在类内部调用类内的方法，不需要对象来调用
        }
    }
}

public class TestThread2 {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();   // 可简单理解为创建任务对象
        MyThread t2 = new MyThread();

        t1.setName("Thread-1");     // 父类Thread中的setName方法
        t2.setName("Thread-2");

        t1.start();                 // start()才是启动线程
        t2.start();

        // 程序会随机在Thread-1与Thread-2中并发交替执行
    }
}
```

### 实现Runnable接口

1. 定义一个实现Runnable的类，表示要执行的任务
2. 重写run()方法
3. 创建自己类的对象
4. 创建一个Thread对象，并start()启动线程

```java
package org.xijuangu;

class MyRun implements Runnable {

    // 此处可以声明构造方法，以传入参数令不同线程执行不同功能

    @Override
    public void run() {
        Thread t = Thread.currentThread();  // 静态方法获取并引用到当前线程对象
        for (int i = 0; i < 100; i++) {
            System.out.println(t.getName() + ": Hello World");    // 这里getName()就不能算是调用类内方法了，需要对象来调用
        }
    }
}

public class TestThread {
    public static void main(String[] args) {
        MyRun myRun = new MyRun();  // 可理解为创建任务对象

        // 创建Thread对象并同时设置任务与线程名
        Thread t1 = new Thread(myRun, "Thread-1");
        Thread t2 = new Thread(myRun, "Thread-2");

        t1.start();
        t2.start();
    }
}
```

### 第三种方法

前两种方法都重写了run()方法，但它的返回值是void，因此我们无法获取多线程运行的结果。这里第三种方法就补充了这种需求。

1. 创建一个实现Callable接口的类
2. 重写call(是有返回值的，表示多线程运行的结果)
3. 创建MyCallable的对象(表示多线程要执行的任务)
4. 创建FutureTask的对象
5. 创建Thread类的对象并启动线程

> FutureTask：
> 异步任务：FutureTask 可以用来提交一个任务，任务会在另一个线程中执行，主线程可以继续执行其他任务，而不用等待子任务完成。
> 结果获取：任务执行完毕后，可以通过 FutureTask 的 get() 方法获取任务的执行结果。如果任务还没有完成，get() 方法会阻塞直到任务完成。
> 取消任务：可以通过 cancel 方法取消任务的执行。
> 任务状态检查：可以通过 isDone 方法检查任务是否完成，通过 isCancelled 方法检查任务是否被取消。

```java
package org.xijuangu;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable<Integer> {     // Callable类有泛型，类型为要返回的数据的类型
    @Override
    public Integer call() throws Exception {        // 注意返回类型
        int sum = 0;
        for(int i = 1; i <= 100; i++){
            sum += i;
        }
        return sum;
    }
}

public class TestThread3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {    // FutureTask的get()方法有抛出必须处理的异常
        MyCallable mc = new MyCallable();   // 创建任务对象
        FutureTask<Integer> ft = new FutureTask<>(mc);  // 创建FutureTask对象并设置任务
        new Thread(ft).start();             // 将FutureTask用以提交任务
        System.out.println(ft.get());       // FutureTask的get()方法获取call()返回的数据
    }
}
```

### 三种方式对比

![alt text](image.png)
