# 排序

## 平均时间复杂度为 n^2

### 冒泡排序

对数组进行遍历，从 i = 0 开始，依次比较 i 与其下一个元素。如果 i 比下一个元素大，就交换他们两个。比较到最后一个元素时，最后一个元素会是最大的数，因此该元素就确定位置了，后面就不需要比较该元素了，因此每趟排序都可以减少一位需要比较的元素，直到排序完成。
持续重复上面的步骤，直到一趟排序中没有任何一对数字需要交换位置。

什么时候最快：当输入的数据已经是正序时，时间复杂度为 O(n)。
什么时候最慢：当输入的数据是反序时，时间复杂度为 O(n^2)。
冒泡排序是一种稳定的排序算法。

### 选择排序

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
重复第二步，直到已排序序列大小等于整个序列。

选择排序无论什么数据规模进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。
选择排序是一种不稳定的排序算法。

### 插入排序

初始状态下已排序队列为空，整个队列都是未排序队列。每次排序会在未排序队列中选择第一个元素，将该元素向前比较，找到第一个比它小的元素或找到已排序队列的队首，插在该元素之后或队首。
重复该步骤，直到无序序列中元素为空。

什么时候最快：当输入的数据已经是正序时，时间复杂度为 O(n)。
什么时候最慢：当输入的数据是反序时，时间复杂度为 O(n^2)。
插入排序是一种稳定的排序算法。

## 平均时间复杂度为 nlogn

### 希尔排序

基本思想：

- 间隔分组：首先选择一个大的间隔（gap），将数组中相隔 gap 距离的元素分为一组，对每组进行插入排序。接着减小间隔，再对这些元素重新进行分组和插入排序，直到间隔缩小到 1，此时进行最后一次插入排序。
- 优化插入排序：通过先使用较大的间隔，可以让数据整体快速趋向有序，而插入排序在处理几乎有序的数据时效率是很高的。因此，希尔排序比直接插入排序更快。

以一个长度为 𝑛 的数组为例：

1. 确定初始的间隔值（gap）：
通常使用 gap=n/2 作为初始值，然后每次对 gap 进行减半，直到最后 gap=1。
2. 按间隔分组进行插入排序：
对于每个间隔 gap，将数组划分为若干组。每组中的元素不是连续的，而是相隔 gap 的元素。对每组的元素分别进行插入排序。
3. 逐步减小间隔，重复插入排序：
每次将间隔减半（或其他减小策略），然后对新的组继续进行插入排序，直到 gap=1。当 gap=1 时，数组已经几乎有序，因此最后一次插入排序能够高效地完成整个排序。

### 归并排序

1. 归并排序步骤：
假设我们有一个长度为 𝑛 的无序数组，归并排序的过程如下：
    1. 分割数组：
    将数组从中间划分为两个部分：左半部分和右半部分。
    对每个部分递归进行归并排序，直到每个子数组只剩下一个元素（单个元素默认有序）。
    2. 排序并合并：
    当两个子数组都排序完成后，将两个排好序的子数组合并成一个新的有序数组。这个合并操作是逐个比较两个子数组中的元素，依次将较小的元素放入新数组。
    3. 重复递归：
    继续重复分割、排序、合并的过程，直到整个数组排序完成。
2. 详细过程：
我们以数组 [12, 11, 13, 5, 6, 7] 为例，来演示归并排序的过程。
    1. 初始数组：[12,11,13,5,6,7]
    2. 第一步：分割数组：
        - 将数组从中间划分为两个子数组：[12,11,13]和[5,6,7]
        - 对这两个子数组分别进行归并排序。
    3. 递归分割左半部分 [12, 11, 13]：
        - 继续将左半部分 [12, 11, 13] 分割为 [12] 和 [11, 13]。
        - [12] 是单个元素，已经有序。
        - 对 [11, 13] 进行归并排序，分为 [11] 和 [13]，它们也都是有序的。
        - 合并 [11] 和 [13]：[11,13]
        - 合并 [12] 和 [11, 13]： 比较 [12] 和 [11, 13] 中的元素，结果为：[11,12,13]
    4. 递归分割右半部分 [5, 6, 7]：
        - 对右半部分 [5, 6, 7] 进行分割，得到 [5] 和 [6, 7]。
        - [5] 已经有序。
        - [6, 7] 是有序的。
        - 合并 [5] 和 [6, 7]： 结果为：[5,6,7]
    5. 合并左右两部分：
        - 现在我们有两个排好序的子数组：[11,12,13]和[5,6,7]
        - 将它们合并，按照从小到大的顺序比较元素，结果为：[5,6,7,11,12,13]
        - 至此，整个数组已经完成排序。
3. 归并排序的合并过程：
假设我们有两个有序数组 𝐿 和 𝑅，它们的大小分别为 𝑛𝐿 和 𝑛𝑅。合并的步骤是：
    1. 分别从 𝐿 和 𝑅 的第一个元素开始比较。
    2. 将较小的元素放入结果数组中，然后继续比较。
    3. 重复上述步骤，直到某个数组的所有元素都被放入结果数组中。
    4. 将剩下的另一个数组中的所有元素依次放入结果数组中。

归并排序的最好情况与最坏情况时间复杂度相同。

### 快速排序

1. 选取基准值（pivot）：从数组中选取一个基准值，可以是第一个元素、最后一个元素或中间元素，甚至可以随机选取，一般选第一个元素。
2. 划分操作：将数组中所有小于基准值的元素移到基准值的左边，所有大于基准值的元素移到基准值的右边。
具体实现步骤：
    1. 初始化左右指针：
        - 左指针指向数组第一个元素。
        - 右指针指向数组最后一个元素。
    2. 开始循环：
        - 将基准元素分别与左指针和右指针相比较。
        - 首先比较右指针，右指针会一直左移直到右指针的值小于基准元素，然后将该小于基准元素的元素赋值给左指针。然后开始比较左指针，左指针会一直右移直到左指针的值大于基准元素，然后将该大于基准元素的元素赋值给右指针，然后再比较右指针，以此类推。
        - 如果左右指针相撞，则结束循环，将基准元素赋值给左指针或右指针。
3. 递归排序：对基准值左边和右边的子数组分别递归进行快速排序。

### 堆排序

见[堆排序](./堆.md)。

## 平均时间复杂度为 n + k
