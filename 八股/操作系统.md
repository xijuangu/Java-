# 操作系统

## 调度

https://blog.csdn.net/chinahyn/article/details/115492293

## 进程间通信

几种进程间通信（IPC）机制：

1. 管道（Pipe）：
管道是一种半双工通信方式，允许数据在进程之间单向流动。它主要用于父子进程之间的通信，数据从写入端流向读取端。管道在操作系统中实现，使用简单，但仅限于具有血缘关系的进程。
2. 信号量（Semaphore）：
信号量是一个计数器，用于控制多个进程对共享资源的访问。通过信号量，进程可以协调对资源的访问，避免竞争条件和死锁。常见的信号量有二进制信号量（只能取0或1）和计数信号量（可以取任意非负整数）。
3. 消息队列（Message Queue）：
消息队列是一种数据结构，通常表现为一个链表，存放在内核中，并通过消息队列标识符进行识别。进程可以将消息发送到队列中，其他进程可以从队列中读取消息。这种方式支持异步通信，适合于需要消息传递的场景。
4. 信号（Signal）：
信号是一种较为复杂的通信方式，用于通知接收进程某个事件已经发生。信号可以用于处理异步事件，如用户中断、定时器到期等。进程可以注册信号处理程序，以便在接收到特定信号时执行相应的操作。
5. 共享内存（Shared Memory）：
共享内存是一种高效的进程间通信方式，允许多个进程访问同一段内存区域。通常由一个进程创建，并映射到其他进程的地址空间。共享内存的优势在于数据传输速度快，但需要使用信号量等机制来协调对共享资源的访问，以避免数据竞争。
6. 套接字（Socket）：
套接字是一种通用的通信机制，广泛用于网络编程。它支持本地和远程进程间的通信，允许客户和服务器之间的数据交换。套接字可以是流式（TCP）或数据报式（UDP），适用于不同的网络应用场景。

## 死锁

死锁产生的四个必要条件：

1. 互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
2. 不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
3. 请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
4. 循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。

以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上循环等待的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。

## 多线程同步

对于多线程程序来说，同步是指在一定的时间内只允许某一个线程来访问某个资源，不允许其他线程同时访问该资源。我们可以通过互斥锁（Mutex）、条件变量（condition variable）、读写锁（reader-writer lock）、信号量（semaphore）来同步资源。

1. 互斥锁（Mutex）
互斥锁用于确保在任何时候只有一个线程可以访问某个共享资源。
在访问共享资源之前，调用 lock() 方法获取锁。
访问完共享资源后，调用 unlock() 方法释放锁。

    ```java
    Mutex mutex = new Mutex();

    void threadFunction() {
        mutex.lock();
        try {
            // 访问共享资源
        } finally {
            mutex.unlock(); // 确保在finally中释放锁
        }
    }
    ```

2. 条件变量（Condition Variable）
条件变量允许线程在特定条件下等待，并在条件满足时被唤醒。
使用互斥锁保护对共享资源的访问。
当某个条件不满足时，调用 wait() 等待；当条件满足时，调用 notify() 或 notifyAll() 唤醒等待的线程。

    ```java
    Mutex mutex = new Mutex();
    ConditionVariable condition = new ConditionVariable();
    boolean conditionMet = false;

    void producer() {
        mutex.lock();
        try {
            // 生产数据
            conditionMet = true;
            condition.signal(); // 通知消费者
        } finally {
            mutex.unlock();
        }
    }

    void consumer() {
        mutex.lock();
        try {
            while (!conditionMet) {
                condition.wait(); // 等待条件满足
            }
            // 消费数据
        } finally {
            mutex.unlock();
        }
    }
    ```

3. 读写锁（Reader-Writer Lock）
读写锁允许多个线程同时读取，但在写入时只有一个线程可以访问共享资源。
读取时获取读锁；写入时获取写锁。

    ```java
    ReadWriteLock rwLock = new ReadWriteLock();

    void readFunction() {
        rwLock.readLock().lock();
        try {
            // 读取共享资源
        } finally {
            rwLock.readLock().unlock();
        }
    }

    void writeFunction() {
        rwLock.writeLock().lock();
        try {
            // 写入共享资源
        } finally {
            rwLock.writeLock().unlock();
        }
    }
    ```

4. 信号量（Semaphore）
信号量控制对共享资源的访问，允许一定数量的线程同时访问。
初始化信号量的许可数量。
线程在访问资源前调用 acquire()，在使用完后调用 release()。

    ```java
    Semaphore semaphore = new Semaphore(3); // 允许3个线程同时访问

    void threadFunction() {
        semaphore.acquire();
        try {
            // 访问共享资源
        } finally {
            semaphore.release();
        }
    }
    ```

## 封装

关于封装：
封装、继承、多态是java面向对象的三大特征，其重要性与使用频率不言而喻。

什么是封装？
封装就是将属性私有化，提供公有的方法来访问私有属性。
做法就是：修改属性的可见性来限制对属性的访问，并为每个属性创建一对取值（getter）方法和赋值（setter）方法，用于对这些属性的访问。
如：

```java
private String name;

public String getName(){
    return name;
}

public void setName(String name){
    this.name = name;
}
```

为什么需要封装？
通过封装，你可以控制如何访问和修改属性，比如确保年龄不能为负数。这种控制力在你需要扩展或修改属性的使用规则时很有用。
以后，如果你决定增加更多逻辑，只需要修改公开的方法，而不用修改其他所有直接使用该属性的代码。
由于对外界隐藏了内部实现，属性如何存储或修改的细节被隔离在方法内部。因此，即使实现方式改变，外部代码依然可以继续使用不变的 getter 和 setter，减少了大规模的代码调整。

举个例子：

假设你有一个类 Person，它包含一个人的年龄属性。最开始，你可能直接把年龄作为 public 属性公开，方便在其他地方直接访问：

```java
public class Person {
    public int age;
}
```

这样，你可以随时设置和获取这个人的年龄：

```java
Person person = new Person();
person.age = 25; // 设置年龄为25
System.out.println(person.age); // 打印年龄
```

如果后来你决定修改业务逻辑，比如要求年龄不能为负数，或者每次设置年龄时需要触发一些其他操作（比如日志记录、通知其他模块等），你就不得不修改所有直接访问 age 的地方。这样就可能引发大规模的修改，导致代码变得难以维护。

**封装的解决方法**
通过封装，你可以将 age 属性设为私有，并提供 getter 和 setter 方法。这样，任何修改都只发生在 getter 和 setter 内部，外部调用代码不会受到影响：

```java
public class Person {
    private int age;

    // 获取年龄
    public int getAge() {
        return age;
    }

    // 设置年龄，添加逻辑：年龄不能为负数
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        } else {
            System.out.println("年龄不能为负数");
        }
    }
}
```

现在，如果其他地方想修改或访问 age，它们只能通过这对方法：

```java
Person person = new Person();
person.setAge(25); // 设置年龄
System.out.println(person.getAge()); // 获取年龄
```

优点
控制访问和修改：通过封装，你可以控制如何访问和修改属性，比如确保年龄不能为负数。这种控制力在你需要扩展或修改属性的使用规则时很有用。
增强可维护性：以后，如果你决定增加更多逻辑，比如设置年龄时更新数据库或发送通知，只需要修改 setAge() 方法，而不用修改其他所有直接使用 age 的代码。
避免大规模修改：由于对外界隐藏了内部实现，属性如何存储或修改的细节被隔离在方法内部。因此，即使实现方式改变，外部代码依然可以继续使用不变的 getter 和 setter，减少了大规模的代码调整。

## 构造函数

**构造函数的定义与省略**
构造函数可以省略。如果没有定义构造函数，Java会自动提供一个默认的无参构造函数。在这种情况下：
· 基本数据类型会有默认值（例如，int 为 0，boolean 为 false）。
· 引用类型会被赋值为 null。

**构造函数与类名**
构造函数必须与类名相同，且没有返回类型。它在对象实例化时被调用，而不是像普通方法一样由用户手动调用。
普通方法：可以与类名相同，但必须显式声明返回类型（例如，void 或其他类型）。

**构造函数的调用时机**
当 new 一个对象时，首先执行类中的（如果有）静态代码块（只执行一次）和实例代码块（每次都会执行），然后调用父类的构造函数（如果有继承关系），最后调用本类的构造函数。构造函数的调用是生成对象实例的最后一步，确保对象在创建时可以被正确初始化。

> Java中类的继承机制意味着子类继承了父类的所有属性和方法。子类对象不仅拥有自己的属性和方法，还继承了父类的部分。因此，当创建子类对象时，这个对象实际上包含了父类的部分内容。
> 父类构造函数的调用是为了确保父类的部分也被正确初始化。这只是在构造过程中初始化父类中的字段，并不会创建父类的独立对象。因此，无论是父类的构造函数还是子类的构造函数，最终都是在构造同一个对象。

**构造函数的重载**
一个类可以有多个构造函数，这称为构造函数的重载。构造函数重载的条件是参数的类型、数量或顺序不同，因此可以根据不同的需求实例化对象。
